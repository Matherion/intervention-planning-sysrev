---
title: "Data Extraction Structure"
author: "Gjalt-Jorn Ygram Peters"
date: "`r format(Sys.time(), '%Y-%m-%d om %X');`"
output: html_document
---

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}

########################################################################
### Paths
########################################################################

### Add any relevant paths to this vector. The script will select the
### correct path itself.

basePathVector <- c("B:/Data/research/intervention-planning-sysrev",
                    "/home/usf/public_html/wim/intervention-planning-sysrev");

########################################################################
### Set the variables with the paths
########################################################################

### Check which paths exist and set the first existing path in the list
### as the base path
basePath <- basePathVector[sapply(basePathVector, dir.exists)][1];
if (is.na(basePath)) stop("None of the basePaths exists!");

### Set the additional paths
outputPath <- basePath;

########################################################################
### Load packages
########################################################################

### Packages
require('userfriendlyscience');
safeRequire('googlesheets');
safeRequire('data.tree');
safeRequire('networkD3')
safeRequire('DiagrammeR')
safeRequire('DiagrammeRsvg')
safeRequire('xtable')
safeRequire('rsvg')
safeRequire('dplyr');
safeRequire('XML')

########################################################################
### Settings (will become parameters/arguments)
########################################################################

newRootName <- 'res';
rootName <- 'intervention';
recursionsName <- 'recursion';
lvlIndentString <- "  ";
repeatingColName <- "Repeating";
recursionColName <- "Recursion";
collapsingColName <- "Collapse";
ownerColName <- "Owner";
parentColName <- "Parent";
identifierColName <- "Identifier";
activityColName <- "Activity";
descriptionColName <- "Description";
definitionsTermsCol = 'Term';
definitionsDefCol = 'Definition';
valueName <- "value";
defaultValue <- "NA";
recursiveElementPlaceholderName <- "recursiveElementPlaceholder";
extractionSheet <- 'Extraction';
definitionsSheet <- 'Definitions';

sheetsURL <- paste0("https://docs.google.com/spreadsheets/d/",
                                 "1g__lA6Qd8x9UcUMIZGq_xMcZt584sJ-1sMaLmxm3nUU");
localextractionSheetFile <- file.path(basePath, 'wim-extractionSheet.csv');
localdefinitionsSheetFile <- file.path(basePath, 'wim-definitionsSheet.csv');

```

```{r functions}

########################################################################
### Functions (to move to metabefor)
########################################################################

wrap <- function(string, width=40) {
  return(paste0(strwrap(string, width=width), collapse="\n"));
}

returnPathToRoot <- function(node, considerRoot = newRootName){#rootName) {
  res <- paste0(rev(unlist(sapply(Traverse(node, traversal='ancestor'),
                                  function(x) return(x$name)),
                           recursive=TRUE)), collapse="$");
  res <- gsub(paste0("^.*\\$", considerRoot, "$"), "", res);
  res <- gsub(paste0("^.*\\$", considerRoot, "\\$"), "\\$", res);
  return(res);
}

isCollapsing <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (trim(toupper(x)) == "OR") {
    return(TRUE);
  } else if (trim(toupper(x)) == "AND") {
    return(TRUE);
  } else {
    stop("For 'Recursion', value '", x, "' encountered.");
  }
}

isRecursive <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (nchar(trim(x)) > 0) {
    return(TRUE);
  }
}

isRepeating <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (trim(toupper(x)) == "FALSE") {
    return(FALSE);
  } else if (trim(toupper(x)) == "TRUE") {
    return(TRUE);
  } else {
    stop("For 'Repeating', value '", x, "' encountered.");
  }
}

hasOwner <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (nchar(trim(x)) > 0) {
    return(TRUE);
  }
}

###############################################################################
###############################################################################
### Extractionscript functions
###############################################################################
###############################################################################

extractionScriptMethod <- function(node,
                                   parentVector = c(parentVector, node$name),
                                   lvlSpaces = "  ",
                                   fillerSymbol = "#",
                                   recursionNesting = 0,
                                   activityColName = "Activity",
                                   descriptionColName = "Description",
                                   repeatingColName = "Repeating",
                                   recursionColName = "Recursion",
                                   collapsingColName = "Collapse",
                                   ownerColName = "Owner",
                                   recursiveElementPlaceholderName = 'recursiveElementPlaceholder') {

  #### Initialize values
  lvlnchar <- nchar(lvlSpaces);
  commentPrefix <- paste0("#", fillerSymbol, fillerSymbol);

  ### Title extraction script
  extractionScript.title <- 
    paste0(lvlSpaces, "#", repStr(fillerSymbol, 79-lvlnchar), "\n",
           lvlSpaces, commentPrefix, "\n",
           paste0(strwrap(toupper(node[[activityColName]]),
                          width=76-lvlnchar,
                          prefix=paste0(lvlSpaces, commentPrefix, " ")),
                  collapse="\n"));
  
  ### Description extraction script (if it exists for this node)
  if (!is.null(node[[descriptionColName]])) {
    extractionScript.description <-
      paste0(lvlSpaces, commentPrefix, "\n",
             paste0(strwrap(node[[descriptionColName]],
                            width=76-lvlnchar,
                            prefix=paste0(lvlSpaces, commentPrefix, " ")),
                    collapse="\n"), "\n");
  }
  
  ### Child addition extraction script
  if (isRecursive(node[[recursionColName]])) {
    
    ### This is a recursive element, which means that if it's a repeating
    ### element, we need to give it a different name, with a number
    
    currentElementName <- ifelse(isRepeating(node[[repeatingColName]]),
                                 paste0(node$name, "_.1._"),
                                 node$name);

    if (node[[recursionColName]] == TRUE) {
      ### We're not in the intervention tree, but in the recursive elements tree,
      ### and we're building the extraction script for that recursive element
      
      ### Add this later
      
    } else if (recursionNesting == 0) {
      ### Currently not in a recursive element, but we will start a recursive element now
      extractionScript.addChild <-
        paste0(lvlSpaces, recursiveElementPlaceholderName, "_", recursionNesting + 1, " <- \n",
               lvlSpaces, "  ", returnPathToRoot(node$parent),
               "$AddChild('", currentElementName, "');");
    } else {
      ### We're already recursing - so we just go one level deeper
      extractionScript.addChild <-
          paste0(lvlSpaces, recursiveElementPlaceholderName, "_", recursionNesting + 1, " <- \n",
                 lvlSpaces, "  ", recursiveElementPlaceholderName, "_", recursionNesting,
                 "$AddChild('", currentElementName, "');");
    }
  } else {
    
    ### This is not a recursive element, so we can just add it. If it is
    ### repeating, we just add a list as value (later on).
    
    extractionScript.addChild <-
      paste0(lvlSpaces,
             returnPathToRoot(node$parent),
             "$AddChild('", node$name, "');");
  }

  ### Now, for leafs, we can add the bit where the value is generated, concatenate
  ### everything, and we can return our result.
  
  ### For branches, we have to retrieve the extractionscripts for all our children,
  ### concatenate this with what we have, and then we can return our result.
  
  ### For recursive elements, we have to generate the scripts for those elements,
  ### concatenate this with what we have, and then we can return our result.

  ### So basically, for those last two, we call ourselves for each child, with the right
  ### recursionNesting and fillerSymbol arguments

}



leafExtractionscript <- function(node, lvlSpaces="  ",
                                 fillerSymbol = "#",
                                 recursionNesting=0) {
  #### Initialize values
  addScoring <- FALSE;
  extraInfo <- "";
  lvlnchar <- nchar(lvlSpaces);
  commentPrefix <- paste0("#", repStr(fillerSymbol, 2));
  nxtLvlSpaces <- repStr(" ", nchar(lvlSpaces) + 2);
  
  ### Start building the extractionscript by adding the TITLE
  rslt <- paste0(lvlSpaces, "#", repStr(fillerSymbol, 79-lvlnchar), "\n",
                 lvlSpaces, commentPrefix, "\n",
                 paste0(strwrap(toupper(node[[activityColName]]),
                                width=76-lvlnchar,
                                prefix=paste0(lvlSpaces, commentPrefix, " ")),
                        collapse="\n"));
  
  ### Add the description
  rslt <- paste0(rslt, "\n",
                 lvlSpaces, commentPrefix, "\n",
                 paste0(strwrap(node[[descriptionColName]],
                                width=76-lvlnchar, prefix=paste0(lvlSpaces, commentPrefix, " ")),
                        collapse="\n"), "\n");

  if (!isRepeating(node[[repeatingColName]]) && !isRecursive(node[[recursionColName]])) {
    ### So this node is the simplest type; it doesn't repeat (only has one value), and
    ### it is not an instance of a recursive fragment.
    rslt <- paste0(rslt,
                   "\n",
                   lvlSpaces, "    ", defaultValue, "\n",
                   "\n");
    addScoring <- TRUE;
  } else if (isRepeating(node[[repeatingColName]]) && !isRecursive(node[[recursionColName]])) {
    ### This node is repeating but not recursive, so a simple list with named elements will do.
    
    rslt <- paste0(rslt,
                   lvlSpaces, commentPrefix, "\n",
                   "\n",
                   lvlSpaces, "    list('",
                   ifelse(is.null(node[[ownerColName]]),
                          node$name,
                          node[[ownerColName]]),
                   "1' = NA,\n",
                   lvlSpaces, "         '",
                   ifelse(is.null(node[[ownerColName]]),
                          node$name,
                          node[[ownerColName]]),
                   "2' = NA)\n",
                   "\n");
    addScoring <- TRUE;
    if (hasOwner(node[[ownerColName]])) {
      ### If this has an owner, coders should make sure it
      ### is coded for each instance of the owner.
      extraInfo <- paste0("\n",
                          lvlSpaces, commentPrefix, "\n",
                          lvlSpaces, commentPrefix,
                          " Must have one list element for each '",
                          node[[ownerColName]],
                          "' element, and\n",
                          lvlSpaces, commentPrefix,
                          " the identifier (e.g. number) of each list element must be ",
                          "the same.");
    }
  } else if (isRecursive(node[[recursionColName]])) {
    ### This node is recursive.
    
    ### Determine the path to the root of this element
    currentElementName <- ifelse(isRepeating(node[[repeatingColName]]),
                                 paste0(node$name, "_.1._"),
                                 node$name)
    currentParentPath <- returnPathToRoot(node$parent);
    currentElementPath <- paste0(currentParentPath, "$", currentElementName);

    ### Check whether this is a repeating node
    if (isRepeating(node[[repeatingColName]])) {
      rslt <- paste0(rslt,
                     lvlSpaces, commentPrefix, "\n",
                     lvlSpaces, commentPrefix, " This recursive element can occur multiple times");
      if (hasOwner(node[[ownerColName]])) {
        rslt <- paste0(rslt, ",\n",
                       lvlSpaces, commentPrefix, " specifically, once for each '",
                       node[[ownerColName]], "'.\n");
      } else {
        rslt <- paste0(rslt, ".\n");
      }
      
      rslt <- paste0(rslt,
                     lvlSpaces, commentPrefix, "\n",
                     lvlSpaces, commentPrefix, " You may want to copy the lines below, until the text\n",
                     lvlSpaces, commentPrefix, " <<<END RECURSIVE ELEMENT ", toupper(node$name), ">>>\n",
                     lvlSpaces, commentPrefix, " and paste them below this first occurrence in case it does\n",
                     lvlSpaces, commentPrefix, " occur more than once.\n");
    }

    
    ### Add the 'placeholder' that is used to add children of the
    ### recursive element. This allows us to work with recursive
    ### elements at arbitrary depths.
    rslt <- paste0(rslt,
                   lvlSpaces, commentPrefix, "\n",
                   lvlSpaces, recursiveElementPlaceholderName, "_", recursionNesting, " <- \n",
                   lvlSpaces, "  ", currentParentPath,
                   "$AddChild('", currentElementName, "');",
                   "\n");

    ### Get recursive element extractionscript
    
    ### If this recursionColName is already in the list with parents, just refer people
    ### to the recursive element at the bottom of the extraction script and tell them to
    ### copy-paste that here.
    
    ### Generate this dynamically - pass the names for all the parents so far.

    recursiveElementExtractionScript <-
      FindNode(extractionScriptTree,
               name=node[[recursionColName]])$Do(extractionScriptMethod,
                                                 parentVector = c(parentVector, node$name),
                                                 lvlSpaces = "  ",
                                                 fillerSymbol = "#",
                                                 recursionNesting = 0);
      
      
      paste0(unlist(FindNode(extractionScriptTree,
                             name=node[[recursionColName]])$Get("extractionscript")),
             collapse="\n");
    
    
    recursiveElementExtractionScript <-
      paste0(unlist(FindNode(extractionScriptTree,
                             name=node[[recursionColName]])$Get("extractionscript")),
             collapse="\n");
    
    ### Add required number of indents
    recursiveElementExtractionScript <- gsub("\n", paste0("\n", nxtLvlSpaces),
                                             paste0(lvlSpaces, recursiveElementExtractionScript));
    

    ### Add recursionNesting number to the recursiveElementPlaceholderName
    recursiveElementExtractionScript <-
      gsub("_\\[\\[NR\\]\\]", paste0("_", recursionNesting),
           recursiveElementExtractionScript);

    ### Attach this recursive element extraction script to the rest
    rslt <- paste0(rslt,
                   recursiveElementExtractionScript);

    ### If it is a repeating recursive element, add the
    ### bit to recognize the end
    if (isRepeating(node[[repeatingColName]])) {
      rslt <- paste0(rslt,
                     lvlSpaces, commentPrefix, " <<<END RECURSIVE ELEMENT ", toupper(node$name), ">>>");
    }

  }
  ### Add scoring, if necessary
  if (addScoring) {
    rslt <- paste0(rslt,
                   paste0(sapply(strsplit(node$Get('Scoring'), "|", fixed=TRUE),
                                 function(x) {
                                   return(strwrap(trim(x), width=76-lvlnchar,
                                                  prefix=paste0(lvlSpaces, commentPrefix, " ")));
                                   }), collapse="\n"));
  }
  rslt <- paste0(rslt, extraInfo);
  
  ### Close this element
  rslt <- paste0(rslt,
                 "\n", lvlSpaces, commentPrefix,
                 "\n", lvlSpaces,
                 "#", repStr(fillerSymbol, 79-lvlnchar), "\n");
  return(rslt);
}

### http://stackoverflow.com/questions/3665115/create-a-file-in-memory-for-user-to-download-not-through-server

###############################################################################
###############################################################################
### Checklist functions
###############################################################################
###############################################################################

generateChecklistElements <- function(node) {

  lvl <- node$level;
  id <- node$name;
  if (isRecursive(node[[recursionColName]]) && !isTrue(node[[recursionColName]])) {
      if (node$trulyRecursive) {
        return("<div>Another truly recursive element</div>");
      }
      ### Insert the recursive element here
    return(paste0('<div class="metabefor-nesting metabefor-nesting-level', lvl, '">\n',
                  '<h', lvl, '>', node$ChecklistTitle, '</h', lvl, '>\n',
                  "<p class='metabefor-checkbox-description'>", node$ChecklistDescription, "</p>",
                  paste0(sapply(FindNode(extractionScriptTree, name=node[[recursionColName]])$children,
                           generateChecklistElements), collapse="\n"),
                  '</div>'));
  } else if (isLeaf(node)) {
    return(paste0("<div class='metabefor-checkbox-container'>",

                  #"<br><br>", node$name, "<br><br>",

                  "<div id='metabefor-checkbox-", node$name, "' class='metabefor-checkbox-svg-container', >",
                  
                  
                  '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 11.1125 11.112501" height="42" width="42"><path style="fill:#FFFFFF;fill-opacity:1;fill-rule:evenodd;stroke:none;" d="M 0.72039847,5.5008244 5.0912096,10.409253 10.343529,0.77453521 4.4461307,7.4949906 Z" class="checkbox-checkmark" /><path style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:0.5291667;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;fill-opacity:1" d="M 0.26458335,0.26458335 H 10.847916 V 10.847916 H 0.26458335 v -10.58333265 0" class="checkbox-border" /></svg>',


                  "</div>",
                  
                  
                  "<div class='metabefor-buttons'>\n",
                  "<div class='metabefor-checklist-title'>\n",
                  node$ChecklistTitle,
                  "</div>",
                  "<div class='metabefor-checkbox-description'>",
                  node$ChecklistDescription,
                  "</div>\n",
                  
                  "<div class='metabefor-book-reference' id='#metabefor-bookreference-", node$name, "'>",
                  ifelse(grepl("[A-Za-z]", node$BookReference),
                         node$BookReference,
                         paste0("More information in the Intervention Mapping book at page ",
                                node$BookReference, " and further.")),
                  "</div>\n",
                  
                  
                  '<div class="btn-group metabefor-buttongroup" data-toggle="buttons" aria-label="Options">\n',
                  '<label class="btn btn-success" onclick="checkboxYes(\'', node$name, '\')">\n',
                  '<input type="radio" name="options" id="metabefor-checkbox-', node$name, '-yes" autocomplete="off"></input> Did this',
                  '</label>',
                  '<label class="btn btn-danger" onclick="checkboxNo(\'', node$name, '\')">\n',
                  '<input type="radio" name="options" id="metabefor-checkbox-', node$name, '-no" autocomplete="off"></input> Did not do this',
                  '</label>',
                  '<label class="btn btn-primary" onclick="checkboxNA(\'', node$name, '\')">\n',
                  '<input type="radio" name="options" id="metabefor-checkbox-', node$name, '-na" autocomplete="off"></input> Not applicable',
                  '</label>',

                  "</div>\n",
                  "\n</div>\n",
                  "</div>"));
  } else {
    return(paste0('<div class="metabefor-nesting metabefor-nesting-level', lvl, '">\n',
                  '<h', lvl, '>', node$ChecklistTitle, '</h', lvl, '>\n',
                  paste0(sapply(node$children, generateChecklistElements), collapse="\n"),
                  '</div>'));
  }
}

renderChecklist <- function(extractionScriptTree,
                            checklistRoot = NULL,
                            preChecklistHtml = NULL,
                            outputFile = NULL,
                            css = "html {\n  font-family: sans-serif;\n}",
                            header = paste0('<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">\n',
                                            '<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>\n',
                                            '<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>\n'),
                            footer = "<script>\n$(document).ready(function(){\n  $('[data-toggle=\"tooltip\"]').tooltip();\n});\n</script>",
                            cssURL = NULL,
                            definitions = NULL,
                            definitionsTermsCol = 'Term',
                            definitionsDefCol = 'Definition') {

  checklistHeader <- "<html>\n\n<head>";
  checklistScript <- "";

  ### Add header info
  if (!is.null(header)) {
    if (file.exists(header)) {
      checklistHeader <- paste0(checklistHeader, '\n',
                                paste0(readLines(header), collapse="\n"),
                                '\n');
    } else {
      checklistHeader <- paste0(checklistHeader, header, '\n');
    }
  }
  
  ### Add stylesheet info
  if (!is.null(cssURL)) {
    checklistHeader <- paste0(checklistHeader, '<link rel="stylesheet" type="text/css" href="', cssURL, '">\n');
  } else if (file.exists(css)) {
    checklistHeader <- paste0(checklistHeader, '<style>\n',
                            paste0(readLines(css), collapse="\n"),
                            '</style>\n');
  } else {
    checklistHeader <- paste0(checklistHeader, "<style>\n", css, "\n</style>\n");
  }
    
  checklistHeader <- paste0(checklistHeader, "</head>\n\n<body>\n");
  
  if (is.null(checklistRoot)) {
    checklistRoot <- extractionScriptTree$root$name;
  }

  checklistBody <- paste0(sapply(FindNode(extractionScriptTree, checklistRoot)$children,
                                 generateChecklistElements),
                          collapse="\n");

  for (i in 1:nrow(definitions)) {
    ### Add tooltip to glossary terms - make sure that the regex SKIPs/FAIL
    ### when inside an A element (i.e. when already inside a tooltop).
    
    ### <a[^>]*>[^<]*<\\/a
    ### <input[^>]*>[^<]*<\\/input
    ### (*SKIP)(*FAIL)
    
    ### See http://www.rexegg.com/regex-best-trick.html
    
    matchString <- paste0("(?:<a[^>]*>[^<]*<\\/a|<input[^>]*>[^<]*<\\/input)(*SKIP)(*FAIL)|(", definitions[i, definitionsTermsCol], ")");
    definitionToolTip <- paste0('<a class="metabefor-term-definition" data-toggle="tooltip" title="',
                                definitions[i, definitionsDefCol],
                                '">\\1</a>');
    # checklistBody <- gsub(matchString, definitionToolTip,
    #                       checklistBody, ignore.case = TRUE, perl=TRUE);
  }

  ### Add footer info
  if (!is.null(footer)) {
    if (file.exists(footer)) {
      checklistFooter <- paste0(readLines(footer), collapse="\n");
    } else {
      checklistFooter <- footer;
    }
  }
  
  definitionTermsOrder <- order(pull(definitions, definitionsTermsCol));
  
  checklistDefinitions <- paste0("<div class='metabefor-definitions-container'>\n",
                                 "<div id='metabefor-definitions-toggle'>\n",
                                 "Glossary (click here to toggle definitions)</div>\n",
                                 "<div id='metabefor-definitions-overflowbox'>",
                                 "<table id='metabefor-definitions'>\n",
                                 paste0(paste0("<tr>\n",
                                               "<td class='metabefor-definitions-term-column'>",
                                               pull(definitions, definitionsTermsCol)[definitionTermsOrder],
                                               "</td>\n",
                                               "<td class='metabefor-definitions-definition-column'>",
                                               pull(definitions, definitionsDefCol)[definitionTermsOrder],
                                               "</td>\n",
                                               "</tr>\n"),
                                        collapse="\n"),
                                 "</table>\n</div>\n",
                                 "</div>\n");
  
  checklistScript <- paste0(checklistScript,
                            '\n$(document).ready(function(){\n',
                            "  var visible = false;",
                            '$( "#metabefor-definitions-toggle" ).click(function() {\n',
                            "  if ( visible ) {\n",
                            "    $( '#metabefor-definitions-overflowbox' ).slideUp('fast',function(){\n",
                            "      $( '#metabefor-definitions-overflowbox' ).addClass('metabefor-hidden')\n",
                            "           .slideDown(0);\n",
                            "    });\n",
                            "  } else {\n",
                            "    $( '#metabefor-definitions-overflowbox' ).slideUp(0,function(){\n",
                            "      $( '#metabefor-definitions-overflowbox' ).removeClass('metabefor-hidden')\n",
                            "           .slideDown('fast');\n",
                            "    });\n",
                            "  }\n",
                            "  visible = ! visible;\n",
                            "});\n",
                            '});');
  
  checklistScript <- paste0(checklistScript, "

  checkboxYes = function(elementIdentifier) {
    $('#metabefor-checkbox-'+elementIdentifier+' .checkbox-checkmark').css(\"fill\", \"#008800\");
    $('#metabefor-checkbox-'+elementIdentifier+' .checkbox-border').css(\"stroke\", \"#008800\");
    $('#metabefor-bookreference-'+elementIdentifier).hide();
  }
  
  checkboxNo = function(elementIdentifier) {
    $('#metabefor-checkbox-'+elementIdentifier+' .checkbox-checkmark').css(\"fill\", \"#FFFFFF\");
    $('#metabefor-checkbox-'+elementIdentifier+' .checkbox-border').css(\"stroke\", \"#880000\");
    $('#metabefor-bookreference-'+elementIdentifier).show();
  }

  checkboxNA = function(elementIdentifier) {
    $('#metabefor-checkbox-'+elementIdentifier+' .checkbox-checkmark').css(\"fill\", \"#FFFFFF\");
    $('#metabefor-checkbox-'+elementIdentifier+' .checkbox-border').css(\"stroke\", \"#CCCCDD\");
    $('#metabefor-bookreference-'+elementIdentifier).hide();
  }

  ");

  preChecklistHtmlText <- "";
  if (!is.null(preChecklistHtml)) {
    if (file.exists(preChecklistHtml)) {
      preChecklistHtmlText <- readLines(preChecklistHtml,
                                        encoding="UTF-8");
    }
  } 

  ### (The metabefor-header and the checklist definitions are placed after the main
  ###  content, so that it's rendered on top of that content.)
  checklistBody <- paste0(checklistHeader, "\n",
                          "\n<div class='metabefor-content-container'>\n",
                          paste(preChecklistHtmlText, collapse="\n", sep="\n"),
                          "\n<div class=\"form-group\">\n",
                          checklistBody, "\n",
                          "</div>\n</div>\n",
                          checklistFooter, "\n",
                          "\n<div class='metabefor-header'>",
                          checklistDefinitions,
                          "</div>\n",
                          "\n</body>\n<script>\n",
                          checklistScript,
                          "\n</script>\n</html>\n");
  
  ### Replace UTF-8 non-breaking spaces with regular spaces
  ### https://stackoverflow.com/questions/14720493/replace-a-utf-8-character-in-r
  checklistBody <- gsub('\U00A0', ' ', checklistBody);

  if (!is.null(outputFile)) {
    outputFileCon <- file(outputFile,
                          "w",
                          encoding="UTF-8");
    writeLines(paste0(checklistBody, collapse=""),
               con=outputFileCon);
    close(outputFileCon);
  }
  
  invisible(checklistBody);

}

```

```{r load-data}

########################################################################
### Load spreadsheet
########################################################################

### Get authorization to read Google sheet
#gs_auth(new_user=TRUE);

### Read google sheet

tryCatch({
  ### Extraction sheet first
  cat0("\nReading extraction sheet from Google Docs.\n");
  dat <- gs_read(gs_url(sheetsURL), ws = extractionSheet);
  cat0("\nStoring extraction sheet in local file.\n");
  write.csv(dat, row.names=FALSE, localextractionSheetFile);
  ### Then definitions sheet
  cat0("\nReading extraction sheet from Google Docs.\n");
  definitions <- gs_read(gs_url(sheetsURL), ws = definitionsSheet);
  cat0("\nStoring extraction sheet in local file.\n");
  write.csv(definitions, row.names=FALSE, localdefinitionsSheetFile);
}, error = function(e) {
  cat0("\nReading extraction sheet from local file.\n");
  dat <<- read.csv(localextractionSheetFile,
                   stringsAsFactors = FALSE);
  cat0("\nReading definitions sheet from local file.\n");
  definitions <<- read.csv(localdefinitionsSheetFile,
                           stringsAsFactors = FALSE);
});

########################################################################
### Process data
########################################################################

dataFrameNetwork <- as.data.frame(dat[!is.na(dat$Identifier),
                                      unique(c('Identifier', 'Parent', names(dat)))]);
dataFrameNetwork$Parent[is.na(dataFrameNetwork$Parent)] <- newRootName;

### Check for non-existent parents
nonExistentParents <- !(dataFrameNetwork$Parent %in% c(newRootName, dataFrameNetwork$Identifier));
if (any(nonExistentParents)) {
  message("Note: the items with the following identifiers have a parent that ",
          "cannot be found in the list of parents: ",
          paste0(paste0("'",
                        dataFrameNetwork$Identifier[nonExistentParents],
                        "' with parent '",
                        dataFrameNetwork$Parent[nonExistentParents],
                        "' on line ", 1+which(dat$Identifier %in% dataFrameNetwork$Identifier[nonExistentParents])),
                 collapse=", "),
          "), so I'm ignoring these.");
}

extractionScriptTree <- FromDataFrameNetwork(dataFrameNetwork);

### Check for unique names
if (!AreNamesUnique(extractionScriptTree)) {
  stop("Not all identifiers are unique!");
}

```

```{r build-graph}

### https://github.com/gluc/data.tree/issues/88
#SetGraphStyle(extractionScriptTree, rankdir = "LR");
#plot(extractionScriptTree);

### Set generic styles
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "black",
                                                    color='black', shape="box",
                                                    style="rounded"));


##################################################################################
### Set specific styles

### Set parent-only nodes to grey
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "grey",
                                                    label = node$Activity,
                                                    color='grey'),
                        filterFun = function(node) return(ifelse(is.null(node$Description), TRUE, FALSE)));

### Set regular nodes
extractionScriptTree$Do(function(node) SetNodeStyle(node, color='black', fontcolor='black',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                           width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Description), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "green", color='green',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Repeating), FALSE, node$Repeating)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded, dotted",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE,
                                                                 ifelse((node$Recursion!='TRUE'), TRUE, FALSE))));

extractionScriptDiagram <- ToDiagrammeRGraph(extractionScriptTree, direction = "descend");

extractionScriptDiagram <- set_global_graph_attrs(extractionScriptDiagram, "layout", "dot", "graph");
extractionScriptDiagram <- add_global_graph_attrs(extractionScriptDiagram, "rankdir", "LR", "graph");

### Temporary to speed up the rest

# render_graph(extractionScriptDiagram);

## Temporarily disabled to speed the script up
export_graph(extractionScriptDiagram,
             file_name=file.path(basePath,
                     "extraction script tree.svg"));

# export_graph(grViz(ToGraphViz(extractionScriptTree)),
#              file_name=file.path(basePath,
#                      "extraction script tree.png"));

```






```{r build-extraction-script}
###################################################################################
### Add extractionscript bits to the tree for recursive extractionscript fragments
###################################################################################

### Set whether an element contains recursive elements, and how many
extractionScriptTree$Do(function(node) {
  node$nrOfRecursiveChildren <-
    max(sum(unlist(sapply(node$Get(recursionColName), isRecursive)))-1, 0)
  });

#cbind(extractionScriptTree$Get('Recursion'), extractionScriptTree$Get('nrOfRecursiveChildren'));

### Check all nodes with recursive children to check whether
### any of are truly recursive
###
### (only prints; commented out)
# extractionScriptTree$Do(function(node) {print(node$name)},
#                         filterFun = function(x, nodeName = node$name)
#                           return(x$nrOfRecursiveChildren>0));

### Store whether a node is truly recursive (i.e. whether it
### contains a recursive element that's its parent)
extractionScriptTree$Do(function(node) {
    node$trulyRecursive <- node[[recursionColName]] %in%
      unlist(sapply(Traverse(node, traversal='ancestor'),
                                         function(x) return(x$name)),
                             recursive=TRUE)[-1];
    node$trulyRecursive <- ifelse(length(node$trulyRecursive)==0,
                                  FALSE, node$trulyRecursive);
  })

recursionRootLevel <- FindNode(extractionScriptTree, name=recursionsName)$level;

FindNode(extractionScriptTree, name=recursionsName)$Do(function(node) {
  if (node$name == recursionsName) {
    ### Initiate or reset extractionScript for this node
    node$extractionscript <- "";
  } else  {
    
    ### How deep we're in this recursion tree
    recursionNesting <- node$level - recursionRootLevel - 1;
    
    ### Relative path to root
    recursiveElementPlaceholderPath <- paste0(recursiveElementPlaceholderName, "_[[NR]]",
                                              returnPathToRoot(node$parent,
                                                               considerRoot = Navigate(node, rep("..", max(1, recursionNesting - 1)))$name));
        
    ### Set two convenience variables to easily generate a pretty extraction script
    lvlSpaces <- repStr(lvlIndentString, recursionNesting);
    lvlnchar <- nchar(lvlSpaces);

    ### A 'truly recursive' is a recursive element that contains itself. That
    ### means that for the inner element, the user has to copy-paste.
    if (node$trulyRecursive) {
        node$extractionscript <- paste0(node$extractionscript, "\n",
                                        lvlSpaces, "#", repStr(">", 79-lvlnchar), "\n",
                                        lvlSpaces, "#>>\n",
                                        paste0(strwrap(paste0("In this file, locate and copy-paste ",
                                                              "the fragment marked '",
                                                              node[[recursionColName]],
                                                              "' here."),
                                                       width=76-lvlnchar, prefix=paste0(lvlSpaces, "#>> ")),
                                                collapse="\n"),
                                        "\n", lvlSpaces, "#>>",
                                        "\n", lvlSpaces, "#", repStr(">", 79-lvlnchar), "\n");
        }
    
    if (recursionNesting==0) {
      node$extractionscript <- paste0(node$extractionscript,
                                      "\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      "#>> ", node$name,
                                      repStr(73-nchar(node$name)), "<<#\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n");
    } else if (recursionNesting > 0) {
      node$extractionscript <- paste0(node$extractionscript,
                                      lvlSpaces,
                                      recursiveElementPlaceholderPath,
                                      "$AddChild('", node$name, "');");
    } else {
      stop("This node has a level *below* the recursion tree root level!");
    }
    
    ### Indicate whether this is a collapsing node
    if (isCollapsing(GetAttribute(node, collapsingColName))) {
      node$extractionscript <- paste0(node$extractionscript,
                                      "\n",
                                      lvlSpaces,
                                      recursiveElementPlaceholderPath,
                                      "$", node$name,
                                      "[['",
                                      collapsingColName,
                                      "']] <- '",
                                      GetAttribute(node, collapsingColName), "';");
    }
    if (isLeaf(node)) {
      ### Start the statement to set the value
      node$extractionscript <- paste0(node$extractionscript, "\n",
                                      lvlSpaces,
                                      recursiveElementPlaceholderPath,
                                      "$", node$name,
                                      "[['", valueName, "']] <-");
    }
    
    if (isNotLeaf(node)) {
      ### So this node has children ('leaves'), which means that the node itself
      ### does not represent any coded element; it's just used for organisation.
      node$extractionscript <- paste0(node$extractionscript, "\n",
                                      lvlSpaces, "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      lvlSpaces, "#>>\n",
                                      paste0(strwrap(toupper(node[[activityColName]]),
                                                     width=76-lvlnchar, prefix=paste0(lvlSpaces, "#>> ")),
                                              collapse="\n"),
                                      "\n", lvlSpaces, "#>>",
                                      "\n", lvlSpaces, "#", repStr(">", 39), repStr("<", 39), "#\n");
    } else {
      ### Run the script to create the code for the scoring of this extraction script bit
      node$extractionscript <-
        paste0(node$extractionscript, "\n",
               leafExtractionscript(node,
                                    lvlSpaces=lvlSpaces,
                                    recursionNesting=recursionNesting,
                                    fillerSymbol = ">"));
    }
    
  }
});

###################################################################################
### Add extractionscript bits to the tree for the regular extractionscript
###################################################################################

rootLevel <- FindNode(extractionScriptTree, name=rootName)$level;

FindNode(extractionScriptTree, name=rootName)$Do(function(node) {

  ### We're just starting, so we're not in any nested recursions yet
  recursionNesting <- 0;
  
  if (node$name == rootName) {
    node$extractionscript <- paste0("### Create 'res' data.tree object\n",
                                    newRootName, " <- Node$new('", newRootName, "');\n",
                                    "\n### Add intervention child element",
                                    "\n", newRootName, "$AddChild('", rootName, "');\n");
  } else {
    
    lvlSpaces <- repStr(lvlIndentString, node$level - rootLevel - 1);
    lvlnchar <- nchar(lvlSpaces);

    if (isRecursive(node[[recursionColName]])) {
      ### If this node is recursive, we shouldn't create the child yet,
      ### And we shouldn't start setting the value yet.
    } else{
      
      ### Add child
      node$extractionscript <- paste0(lvlSpaces,
                                      returnPathToRoot(node$parent),
                                      "$AddChild('", node$name, "');");
      
      ### Indicate whether this is a collapsing node
      if (isCollapsing(GetAttribute(node, collapsingColName))) {
        node$extractionscript <- paste0(node$extractionscript,
                                        "\n",
                                        lvlSpaces,
                                        returnPathToRoot(node), "[['",
                                        collapsingColName,
                                        "']] <- '",
                                        GetAttribute(node, collapsingColName), "';");
      }
      if (isLeaf(node)) {
        ### Start the statement to set the value
        node$extractionscript <- paste0(node$extractionscript, "\n",
                                        lvlSpaces,
                                        returnPathToRoot(node), "[['", valueName, "']] <-");
      }
    }

    if (isNotLeaf(node)) {
      ### So this node has children ('leaves'), which means that the node itself
      ### does not represent any coded element; it's just used for organisation.
      node$extractionscript <- paste0(node$extractionscript, "\n",
                                      lvlSpaces, repStr("#", 80-lvlnchar), "\n",
                                      lvlSpaces, "###\n",
                                      paste0(strwrap(toupper(node[[activityColName]]),
                                                     width=76-lvlnchar, prefix=paste0(lvlSpaces, "### ")),
                                              collapse="\n"),
                                      "\n", lvlSpaces, "###",
                                      "\n", lvlSpaces,repStr("#", 80-lvlnchar), "\n\n");
    } else {
      ### Run the script to create the code for the scoring of this extraction script bit
      node$extractionscript <-
        paste0(node$extractionscript, "\n",
               leafExtractionscript(node,
                                    lvlSpaces=lvlSpaces,
                                    recursionNesting=recursionNesting));
    }
      
  }
});

extractionScriptBody <- paste0(repStr("#", 80), "\n",
                               repStr("#", 80), "\n",
                               "######", repStr(68), "######\n",
                               "######       ",
                               "M E T A B E F O R    E X T R A C T I O N   S C R I P T",
                               "       ######\n",
                               "######", repStr(68), "######\n",
                               repStr("#", 80), "\n",
                               repStr("#", 80), "\n\n");

### Extract all extraction script bits
extractionScriptBody <- paste0(extractionScriptBody,
                               paste0(unlist(FindNode(extractionScriptTree, 
                                                      name=rootName)$Get("extractionscript")),
                                      collapse="\n"));

### Add extractionscript bits to the tree, now for the
### recursive elements

extractionScriptBody <- paste0(extractionScriptBody,
                               "\n", repStr("#", 80), "\n",
                               repStr("#", 80), "\n",
                               "######", repStr(68), "######\n",
                               "######                ",
                               "R E C U R S I V E   E L E M E N T S",
                               "                 ######\n",
                               "######", repStr(68), "######\n",
                               repStr("#", 80), "\n",
                               repStr("#", 80), "\n");

extractionScriptBody <- paste0(extractionScriptBody,
                               paste0(unlist(FindNode(extractionScriptTree,
                                                      name=recursionsName)$Get("extractionscript")),
                                      collapse="\n"));

extractionScript <- extractionScriptBody;

writeLines(paste0(extractionScript, collapse=""),
           file.path(basePath,
                     "extraction script template foundation.R"));

```

```{r build-checklist}

###############################################################################
###############################################################################
### Generate checklist                                                      ###
###############################################################################
###############################################################################

renderChecklist(extractionScriptTree,
                checklistRoot = 'intervention',
                preChecklistHtml = file.path(basePath, "checklist_frontpage.html"),
                outputFile = file.path(basePath, "checklist.html"),
                css = file.path(basePath, 'checklist.css'),
                definitions = definitions);

### Upload checklist
# if (require('RCurl')) {
#   if (url.exists('http://interventionchecklist.com/')) {
#     ftpUpload(file.path(packageBuildingPath, binFile),
#               paste0("ftp://userfriendlyscience.com/", binFile),
#               userpwd="packageUploads@interventionchecklist.com:Ju=1_pyT3@V6KR30qq8V");
#   }
# }

###############################################################################

```
