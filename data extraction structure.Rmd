---
title: "Data Extraction Structure"
author: "Gjalt-Jorn Ygram Peters"
date: "`r format(Sys.time(), '%Y-%m-%d om %X');`"
output: html_document
---

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}

########################################################################
### Paths
########################################################################

### Add any relevant paths to this vector. The script will select the
### correct path itself.

basePathVector <- c("B:/Data/research/intervention-planning-sysrev",
                    "/home/usf/public_html/wim/intervention-planning-sysrev");

########################################################################
### Set the variables with the paths
########################################################################

### Check which paths exist and set the first existing path in the list
### as the base path
basePath <- basePathVector[sapply(basePathVector, dir.exists)][1];
if (is.na(basePath)) stop("None of the basePaths exists!");

### Set the additional paths
outputPath <- basePath;

########################################################################
### Load packages
########################################################################

### Packages
require('userfriendlyscience');
safeRequire('googlesheets');
safeRequire('data.tree');
safeRequire('networkD3')
safeRequire('DiagrammeR')
safeRequire('DiagrammeRsvg')
safeRequire('xtable')
safeRequire('rsvg')
safeRequire('dplyr');

########################################################################
### Settings (will become parameters/arguments)
########################################################################

newRootName <- 'res';
rootName <- 'intervention';
recursionsName <- 'recursion';
lvlIndentString <- "  ";
repeatingColName <- "Repeating";
recursionColName <- "Recursion";
collapsingColName <- "Collapse";
ownerColName <- "Owner";
parentColName <- "Parent";
identifierColName <- "Identifier";
activityColName <- "Activity";
descriptionColName <- "Description";
definitionsTermsCol = 'Term';
definitionsDefCol = 'Definition';
valueName <- "value";
defaultValue <- "NA";
recursiveElementPlaceholderName <- "recursiveElementPlaceholder";
extractionSheet <- 'Extraction';
definitionsSheet <- 'Definitions';

sheetsURL <- paste0("https://docs.google.com/spreadsheets/d/",
                                 "1g__lA6Qd8x9UcUMIZGq_xMcZt584sJ-1sMaLmxm3nUU");
localextractionSheetFile <- file.path(basePath, 'wim-extractionSheet.csv');
localdefinitionsSheetFile <- file.path(basePath, 'wim-definitionsSheet.csv');

```

```{r functions}

########################################################################
### Functions (to move to metabefor)
########################################################################

wrap <- function(string, width=40) {
  return(paste0(strwrap(string, width=width), collapse="\n"));
}

returnPathToRoot <- function(node, considerRoot = newRootName){#rootName) {
  res <- paste0(rev(unlist(sapply(Traverse(node, traversal='ancestor'),
                                  function(x) return(x$name)),
                           recursive=TRUE)), collapse="$");
  res <- gsub(paste0("^.*\\$", considerRoot, "$"), "", res);
  res <- gsub(paste0("^.*\\$", considerRoot, "\\$"), "\\$", res);
  return(res);
}

isCollapsing <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (trim(toupper(x)) == "OR") {
    return(TRUE);
  } else if (trim(toupper(x)) == "AND") {
    return(TRUE);
  } else {
    stop("For 'Recursion', value '", x, "' encountered.");
  }
}

isRecursive <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (nchar(trim(x)) > 0) {
    return(TRUE);
  }
}

isRepeating <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (trim(toupper(x)) == "FALSE") {
    return(FALSE);
  } else if (trim(toupper(x)) == "TRUE") {
    return(TRUE);
  } else {
    stop("For 'Repeating', value '", x, "' encountered.");
  }
}

hasOwner <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (nchar(trim(x)) > 0) {
    return(TRUE);
  }
}

leafExtractionscript <- function(node, lvlSpaces="  ",
                                 fillerSymbol = "#",
                                 recursionNesting=0) {
  #### Initialize values
  addScoring <- FALSE;
  extraInfo <- "";
  lvlnchar <- nchar(lvlSpaces);
  commentPrefix <- paste0("#", repStr(fillerSymbol, 2));
  ### Start scriptbit
  rslt <- paste0(lvlSpaces, "#", repStr(fillerSymbol, 79-lvlnchar), "\n",
                 lvlSpaces, commentPrefix, "\n",
                 paste0(strwrap(toupper(node[[activityColName]]),
                                width=76-lvlnchar, prefix=paste0(lvlSpaces, commentPrefix, " ")),
                        collapse="\n"));
  
  
    
# rslt <- paste0(rslt, "\n\n------ ", recursionNesting, "\n",
#                Navigate(node, rep("..", recursionNesting))$name, "\n",
#                returnPathToRoot(node$parent, considerRoot = Navigate(node, rep("..", recursionNesting))$name),
#                "\n\n");



  if (!isRepeating(node[[repeatingColName]]) && !isRecursive(node[[recursionColName]])) {
    ### So this node is the simplest type; it doesn't repeat (only has one value), and
    ### it is not an instance of a recursive fragment.
    rslt <- paste0(rslt, "\n",
                   lvlSpaces, commentPrefix, "\n",
                   paste0(strwrap(node[[descriptionColName]],
                                  width=76-lvlnchar, prefix=paste0(lvlSpaces, commentPrefix, " ")),
                          collapse="\n"), "\n",
                   "\n",
                   lvlSpaces, "    ", defaultValue, "\n",
                   "\n");
    addScoring <- TRUE;
  } else if (isRepeating(node[[repeatingColName]]) && !isRecursive(node[[recursionColName]])) {
    ### This node is repeating but not recursive, so a simple list with named elements will do.
    
    rslt <- paste0(rslt, "\n",
                   lvlSpaces, commentPrefix, "\n",
                   paste0(strwrap(node[[descriptionColName]],
                                  width=76-lvlnchar, prefix=paste0(lvlSpaces, commentPrefix, " ")),
                          collapse="\n"), "\n",
                   lvlSpaces, commentPrefix, "\n",
                   "\n",
                   lvlSpaces, "    list('",
                   ifelse(is.null(node[[ownerColName]]),
                          node$name,
                          node[[ownerColName]]),
                   "1' = NA,\n",
                   lvlSpaces, "         '",
                   ifelse(is.null(node[[ownerColName]]),
                          node$name,
                          node[[ownerColName]]),
                   "2' = NA)\n",
                   "\n");
    addScoring <- TRUE;
    if (hasOwner(node[[ownerColName]])) {
      extraInfo <- paste0("\n",
                          lvlSpaces, commentPrefix, "\n",
                          lvlSpaces, commentPrefix, " Must have one list element for each '",
                          node[[ownerColName]],
                          "' element, and\n",
                          lvlSpaces, commentPrefix, " the name of each list element must be ",
                          "the same.");
    }
  } else if (isRecursive(node[[recursionColName]])) {
    ### This node is recursive, and so probably repeating.
    
    ### Determine the path to the root of this element
    currentElementName <- ifelse(isRepeating(node[[repeatingColName]]),
                                 paste0(node$name, "_.1._"),
                                 node$name)
    currentParentPath <- returnPathToRoot(node$parent);
    currentElementPath <- paste0(currentParentPath, "$", currentElementName);
    
    rslt <- paste0(rslt, "\n",
                   lvlSpaces, commentPrefix, "\n",
                   paste0(strwrap(node[[descriptionColName]],
                                  width=76-lvlnchar, prefix=paste0(lvlSpaces, commentPrefix, " ")),
                          collapse="\n"), "\n",
                   lvlSpaces, commentPrefix, "\n",
                   paste0(strwrap(paste0("In this file, locate and copy-paste the fragment marked '",
                                                              node[[recursionColName]],
                                                              "' here."),
                                                       width=76-lvlnchar, prefix=paste0(lvlSpaces, commentPrefix, ' ')),
                                                collapse="\n"),
                   "\n",
                   lvlSpaces, commentPrefix, "\n");
        
    if (isRepeating(node[[repeatingColName]])) {
      rslt <- paste0(rslt,
                     lvlSpaces, commentPrefix, " This recursive element can occur multiple times");
      if (hasOwner(node[[ownerColName]])) {
        rslt <- paste0(rslt, ",\n",
                       lvlSpaces, commentPrefix, " specifically, once for each '",
                       node[[ownerColName]], "'.\n");
      }
      rslt <- paste0(rslt,
                     lvlSpaces, commentPrefix, "\n",
                     lvlSpaces, commentPrefix, " You may want to copy the lines below, until the text\n",
                     lvlSpaces, commentPrefix, " <<<END RECURSIVE ELEMENT ", toupper(node$name), ">>>\n",
                     lvlSpaces, commentPrefix, " and paste them below this first occurrence in case it does\n",
                     lvlSpaces, commentPrefix, " occur more than once.\n");
    }

    rslt <- paste0(rslt,
                   lvlSpaces, commentPrefix, "\n",
                   lvlSpaces, "    recursiveElementPlaceholder <- ", currentParentPath,
                   "$AddChild('", currentElementName, "');\n",
                   "\n");

    ### Get recursive element extractionscript
    recursiveElementExtractionScript <-
      paste0(unlist(FindNode(extractionScriptTree, name=node[[recursionColName]])$Get("extractionscript")), collapse="\n");
    
    ### Add required number of indents
    recursiveElementExtractionScript <- gsub("\n", paste0("\n", lvlSpaces),
                                             paste0(lvlSpaces, recursiveElementExtractionScript));
    
    rslt <- paste0(rslt,
                   recursiveElementExtractionScript);

    if (isRepeating(node[[repeatingColName]])) {
      rslt <- paste0(rslt,
                     lvlSpaces, commentPrefix, " <<<END RECURSIVE ELEMENT ", toupper(node$name), ">>>");
    }

  }
  ### Add scoring, if necessary
  if (addScoring) {
    rslt <- paste0(rslt,
                   paste0(sapply(strsplit(node$Get('Scoring'), "|", fixed=TRUE),
                                 function(x) {
                                   return(strwrap(trim(x), width=76-lvlnchar,
                                                  prefix=paste0(lvlSpaces, commentPrefix, " ")));
                                   }), collapse="\n"));
  }
  rslt <- paste0(rslt, extraInfo);
  
  ### Close this element
  rslt <- paste0(rslt,
                 "\n", lvlSpaces, commentPrefix,
                 "\n", lvlSpaces,
                 "#", repStr(fillerSymbol, 79-lvlnchar), "\n");
  return(rslt);
}

### http://stackoverflow.com/questions/3665115/create-a-file-in-memory-for-user-to-download-not-through-server

generateChecklistElements <- function(node) {

  lvl <- node$level;
  id <- node$name;
  if (isRecursive(node[[recursionColName]]) && !isTrue(node[[recursionColName]])) {
      if (node$trulyRecursive) {
        return("<div>Another truly recursive element</div>");
      }
      ### Insert the recursive element here
    return(paste0('<div class="metabefor-nesting metabefor-nesting-level', lvl, '">\n',
                  '<h', lvl, '>', node$ChecklistTitle, '</h', lvl, '>\n',
                  "<p class='metabefor-checkbox-description'>", node$ChecklistDescription, "</p>",
                  paste0(sapply(FindNode(extractionScriptTree, name=node[[recursionColName]])$children,
                           generateChecklistElements), collapse="\n"),
                  '</div>'));
  } else if (isLeaf(node)) {
    return(paste0("<div class='metabefor-checkbox-container'>",
                  
                  "<br><br>", node$name, "<br><br>",
                  
                  "<div class='checkbox metabefor-checkbox'>\n",
                  "<label class=\"metabefor-checkbox-label\"><input type='checkbox' class='metabefor-checkbox-actualcheckbox' name='", id, "' />\n",
                  node$ChecklistTitle, "</label>\n</div>\n",
                  "<p class='metabefor-checkbox-description'>", node$ChecklistDescription, "</p>",
                  "<p class='metabefor-book-reference'>",
                  "More information in the Intervention Mapping book at page ",
                  node$BookReference, " and further.</p>\n",
                  "</div>"));
  } else {
    return(paste0('<div class="metabefor-nesting metabefor-nesting-level', lvl, '">\n',
                  '<h', lvl, '>', node$ChecklistTitle, '</h', lvl, '>\n',
                  paste0(sapply(node$children, generateChecklistElements), collapse="\n"),
                  '</div>'));
  }
}

renderChecklist <- function(extractionScriptTree,
                            checklistRoot = NULL,
                            outputFile = NULL,
                            css = "html {\n  font-family: sans-serif;\n}",
                            header = paste0('<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">\n',
                                            '<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>\n',
                                            '<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>\n'),
                            footer = "<script>\n$(document).ready(function(){\n  $('[data-toggle=\"tooltip\"]').tooltip();\n});\n</script>",
                            cssURL = NULL,
                            definitions = NULL,
                            definitionsTermsCol = 'Term',
                            definitionsDefCol = 'Definition') {

  checklistHeader <- "<html>\n\n<head>";
  checklistScript <- "";

  ### Add header info
  if (!is.null(header)) {
    if (file.exists(header)) {
      checklistHeader <- paste0(checklistHeader, '\n',
                                paste0(readLines(header), collapse="\n"),
                                '\n');
    } else {
      checklistHeader <- paste0(checklistHeader, header, '\n');
    }
  }
  
  ### Add stylesheet info
  if (!is.null(cssURL)) {
    checklistHeader <- paste0(checklistHeader, '<link rel="stylesheet" type="text/css" href="', cssURL, '">\n');
  } else if (file.exists(css)) {
    checklistHeader <- paste0(checklistHeader, '<style>\n',
                            paste0(readLines(css), collapse="\n"),
                            '</style>\n');
  } else {
    checklistHeader <- paste0(checklistHeader, "<style>\n", css, "\n</style>\n");
  }
    
  checklistHeader <- paste0(checklistHeader, "</head>\n\n<body>\n");

  if (is.null(checklistRoot)) {
    checklistRoot <- extractionScriptTree$root$name;
  }

  checklistBody <- paste0(sapply(FindNode(extractionScriptTree, checklistRoot)$children,
                                 generateChecklistElements),
                          collapse="\n");

  for (i in 1:nrow(definitions)) {
    matchString <- paste0("(", definitions[i, definitionsTermsCol], ")");
    definitionToolTip <- paste0('<a class="metabefor-term-definition" data-toggle="tooltip" title="',
                                definitions[i, definitionsDefCol],
                                '">\\1</a>');
    checklistBody <- gsub(matchString, definitionToolTip,
                          checklistBody, ignore.case = TRUE);
  }

  ### Add footer info
  if (!is.null(footer)) {
    if (file.exists(footer)) {
      checklistFooter <- paste0(readLines(footer), collapse="\n");
    } else {
      checklistFooter <- footer;
    }
  }
  
  definitionTermsOrder <- order(pull(definitions, definitionsTermsCol));
  
  checklistDefinitions <- paste0("<div class='metabefor-definitions-container'>\n",
                                 "<div id='metabefor-definitions-toggle'>\n",
                                 "Glossary (click here to toggle definitions)</div>\n",
                                 "<div id='metabefor-definitions-overflowbox'>",
                                 "<table id='metabefor-definitions'>\n",
                                 paste0(paste0("<tr>\n",
                                               "<td class='metabefor-definitions-term-column'>",
                                               pull(definitions, definitionsTermsCol)[definitionTermsOrder],
                                               "</td>\n",
                                               "<td class='metabefor-definitions-definition-column'>",
                                               pull(definitions, definitionsDefCol)[definitionTermsOrder],
                                               "</td>\n",
                                               "</tr>\n"),
                                        collapse="\n"),
                                 "</table>\n</div>\n",
                                 "</div>\n");
  
  checklistScript <- paste0(checklistScript,
                            '$( "#metabefor-definitions-toggle" ).click(function() {',
                            '  $( "#metabefor-definitions-overflowbox" ).toggle();',
                            '});');
  
  ### (The metabefor-header and the checklist definitions are placed after the main
  ###  content, so that it's rendered on top of that content.)
  checklistBody <- paste0(checklistHeader,
                          "\n<div class='metabefor-content-container'>\n",
                          "\n<div class=\"form-group\">\n",
                          checklistBody, "\n",
                          "</div>\n</div>\n",
                          checklistFooter, "\n",
                          "\n<div class='metabefor-header'>",
                          checklistDefinitions,
                          "</div>\n",
                          "\n</body>\n<script>\n",
                          checklistScript,
                          "\n</script>\n</html>\n");
  
  ### Replace UTF-8 non-breaking spaces with regular spaces
  ### https://stackoverflow.com/questions/14720493/replace-a-utf-8-character-in-r
  checklistBody <- gsub('\U00A0', ' ', checklistBody);

  if (!is.null(outputFile)) {
    outputFileCon <- file(outputFile,
                          "w",
                          encoding="UTF-8");
    writeLines(paste0(checklistBody, collapse=""),
               con=outputFileCon);
    close(outputFileCon);
  }
  
  invisible(checklistBody);

}

```

```{r load-data}

########################################################################
### Load spreadsheet
########################################################################

### Get authorization to read Google sheet
#gs_auth(new_user=TRUE);

### Read google sheet

tryCatch({
  ### Extraction sheet first
  cat0("\nReading extraction sheet from Google Docs.\n");
  dat <- gs_read(gs_url(sheetsURL), ws = extractionSheet);
  cat0("\nStoring extraction sheet in local file.\n");
  write.csv(dat, row.names=FALSE, localextractionSheetFile);
  ### Then definitions sheet
  cat0("\nReading extraction sheet from Google Docs.\n");
  definitions <- gs_read(gs_url(sheetsURL), ws = definitionsSheet);
  cat0("\nStoring extraction sheet in local file.\n");
  write.csv(definitions, row.names=FALSE, localdefinitionsSheetFile);
}, error = function(e) {
  cat0("\nReading extraction sheet from local file.\n");
  dat <<- read.csv(localextractionSheetFile,
                   stringsAsFactors = FALSE);
  cat0("\nReading definitions sheet from local file.\n");
  definitions <<- read.csv(localdefinitionsSheetFile,
                           stringsAsFactors = FALSE);
});

########################################################################
### Process data
########################################################################

dataFrameNetwork <- as.data.frame(dat[!is.na(dat$Identifier),
                                      unique(c('Identifier', 'Parent', names(dat)))]);
dataFrameNetwork$Parent[is.na(dataFrameNetwork$Parent)] <- newRootName;

### Check for non-existent parents
nonExistentParents <- !(dataFrameNetwork$Parent %in% c(newRootName, dataFrameNetwork$Identifier));
if (any(nonExistentParents)) {
  message("Note: the items with the following identifiers have a parent that ",
          "cannot be found in the list of parents: ",
          paste0(paste0("'",
                        dataFrameNetwork$Identifier[nonExistentParents],
                        "' with parent '",
                        dataFrameNetwork$Parent[nonExistentParents],
                        "' on line ", 1+which(dat$Identifier %in% dataFrameNetwork$Identifier[nonExistentParents])),
                 collapse=", "),
          "), so I'm ignoring these.");
}

extractionScriptTree <- FromDataFrameNetwork(dataFrameNetwork);

### Check for unique names
if (!AreNamesUnique(extractionScriptTree)) {
  stop("Not all identifiers are unique!");
}

```

```{r build-graph}

### https://github.com/gluc/data.tree/issues/88
#SetGraphStyle(extractionScriptTree, rankdir = "LR");
#plot(extractionScriptTree);

### Set generic styles
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "black",
                                                    color='black', shape="box",
                                                    style="rounded"));


##################################################################################
### Set specific styles

### Set parent-only nodes to grey
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "grey",
                                                    label = node$Activity,
                                                    color='grey'),
                        filterFun = function(node) return(ifelse(is.null(node$Description), TRUE, FALSE)));

### Set regular nodes
extractionScriptTree$Do(function(node) SetNodeStyle(node, color='black', fontcolor='black',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                           width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Description), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "green", color='green',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Repeating), FALSE, node$Repeating)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded, dotted",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE,
                                                                 ifelse((node$Recursion!='TRUE'), TRUE, FALSE))));

extractionScriptDiagram <- ToDiagrammeRGraph(extractionScriptTree, direction = "descend");

extractionScriptDiagram <- set_global_graph_attrs(extractionScriptDiagram, "layout", "dot", "graph");
extractionScriptDiagram <- add_global_graph_attrs(extractionScriptDiagram, "rankdir", "LR", "graph");

### Temporary to speed up the rest

# render_graph(extractionScriptDiagram);

export_graph(extractionScriptDiagram,
             file_name=file.path(basePath,
                     "extraction script tree.svg"));

# export_graph(grViz(ToGraphViz(extractionScriptTree)),
#              file_name=file.path(basePath,
#                      "extraction script tree.png"));

```

```{r build-extraction-script}
###################################################################################
### Add extractionscript bits to the tree for recursive extractionscript fragments
###################################################################################

### Set whether an element contains recursive elements, and how many
extractionScriptTree$Do(function(node) {
  node$nrOfRecursiveChildren <-
    max(sum(unlist(sapply(node$Get(recursionColName), isRecursive)))-1, 0)
  });

#cbind(extractionScriptTree$Get('Recursion'), extractionScriptTree$Get('nrOfRecursiveChildren'));

### Check all nodes with recursive children to check whether
### any of are truly recursive
###
### (only prints; commented out)
# extractionScriptTree$Do(function(node) {print(node$name)},
#                         filterFun = function(x, nodeName = node$name)
#                           return(x$nrOfRecursiveChildren>0));

### Store whether a node is truly recursive (i.e. whether it
### contains a recursive element that's its parent)
extractionScriptTree$Do(function(node) {
    node$trulyRecursive <- node[[recursionColName]] %in%
      unlist(sapply(Traverse(node, traversal='ancestor'),
                                         function(x) return(x$name)),
                             recursive=TRUE)[-1];
    node$trulyRecursive <- ifelse(length(node$trulyRecursive)==0,
                                  FALSE, node$trulyRecursive);
  })

recursionRootLevel <- FindNode(extractionScriptTree, name=recursionsName)$level;

FindNode(extractionScriptTree, name=recursionsName)$Do(function(node) {
  if (node$name == recursionsName) {
    ### Initiate or reset extractionScript for this node
    node$extractionscript <- "";
  } else  {
    
    ### How deep we're in this recursion tree
    recursionNesting <- node$level - recursionRootLevel - 1;
    
    ### Relative path to root
    recursiveElementPlaceholderPath <- paste0(recursiveElementPlaceholderName,
                                              returnPathToRoot(node$parent,
                                                               considerRoot = Navigate(node, rep("..", max(1, recursionNesting - 1)))$name));
        
    ### Set two convenience variables to easily generate a pretty extraction script
    lvlSpaces <- repStr(lvlIndentString, recursionNesting);
    lvlnchar <- nchar(lvlSpaces);

    ### A 'truly recursive' is a recursive element that contains itself. That
    ### means that for the inner element, the user has to copy-paste.
    if (node$trulyRecursive) {
        node$extractionscript <- paste0(node$extractionscript, "\n",
                                        lvlSpaces, "#", repStr(">", 79-lvlnchar), "\n",
                                        lvlSpaces, "#>>\n",
                                        paste0(strwrap(paste0("In this file, locate and copy-paste the fragment marked '",
                                                              node[[recursionColName]],
                                                              "' here."),
                                                       width=76-lvlnchar, prefix=paste0(lvlSpaces, "#>> ")),
                                                collapse="\n"),
                                        "\n", lvlSpaces, "#>>",
                                        "\n", lvlSpaces, "#", repStr(">", 79-lvlnchar), "\n");
        }
    
    if (recursionNesting==0) {
      node$extractionscript <- paste0(node$extractionscript,
                                      "\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      "#>> ", node$name,
                                      repStr(73-nchar(node$name)), "<<#\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      "#", repStr(">", 39), repStr("<", 39), "#\n");
    } else if (recursionNesting > 0) {
      node$extractionscript <- paste0(node$extractionscript,
                                      lvlSpaces,
                                      recursiveElementPlaceholderPath,
                                      "$AddChild('", node$name, "');\n");
    } else {
      stop("This node has a level *below* the recursion tree root level!");
    }
    
    ### Indicate whether this is a collapsing node
    if (isCollapsing(GetAttribute(node, collapsingColName))) {
      node$extractionscript <- paste0(node$extractionscript,
                                      "\n",
                                      lvlSpaces,
                                      recursiveElementPlaceholderPath,
                                      "$", node$name,
                                      "[['",
                                      collapsingColName,
                                      "']] <- '",
                                      GetAttribute(node, collapsingColName), "';");
    }
    if (isLeaf(node)) {
      ### Start the statement to set the value
      node$extractionscript <- paste0(node$extractionscript, "\n",
                                      lvlSpaces,
                                      recursiveElementPlaceholderPath,
                                      "$", node$name,
                                      "[['", valueName, "']] <-");
    }
    
    if (isNotLeaf(node)) {
      ### So this node has children ('leaves'), which means that the node itself
      ### does not represent any coded element; it's just used for organisation.
      node$extractionscript <- paste0(node$extractionscript, "\n",
                                      lvlSpaces, "#", repStr(">", 39), repStr("<", 39), "#\n",
                                      lvlSpaces, "#>>\n",
                                      paste0(strwrap(toupper(node[[activityColName]]),
                                                     width=76-lvlnchar, prefix=paste0(lvlSpaces, "#>> ")),
                                              collapse="\n"),
                                      "\n", lvlSpaces, "#>>",
                                      "\n", lvlSpaces, "#", repStr(">", 39), repStr("<", 39), "#\n");
    } else {
      ### Run the script to create the code for the scoring of this extraction script bit
      node$extractionscript <-
        paste0(node$extractionscript, "\n",
               leafExtractionscript(node,
                                    lvlSpaces=lvlSpaces,
                                    recursionNesting=recursionNesting,
                                    fillerSymbol = ">"));
    }
    
  }
});

###################################################################################
### Add extractionscript bits to the tree for the regular extractionscript
###################################################################################

rootLevel <- FindNode(extractionScriptTree, name=rootName)$level;

FindNode(extractionScriptTree, name=rootName)$Do(function(node) {

  ### We're just starting, so we're not in any nested recursions yet
  recursionNesting <- 0;
  
  if (node$name == rootName) {
    node$extractionscript <- paste0("### Create 'res' data.tree object\n",
                                    newRootName, " <- Node$new('", newRootName, "');\n",
                                    "\n### Add intervention child element",
                                    "\n", newRootName, "$AddChild('", rootName, "');\n");
  } else {
    
    lvlSpaces <- repStr(lvlIndentString, node$level - rootLevel - 1);
    lvlnchar <- nchar(lvlSpaces);

    if (isRecursive(node[[recursionColName]])) {
      ### If this node is recursive, we shouldn't create the child yet,
      ### And we shouldn't start setting the value yet.
    } else{
      
      ### Add child
      node$extractionscript <- paste0(lvlSpaces,
                                      returnPathToRoot(node$parent),
                                      "$AddChild('", node$name, "');");
      
      ### Indicate whether this is a collapsing node
      if (isCollapsing(GetAttribute(node, collapsingColName))) {
        node$extractionscript <- paste0(node$extractionscript,
                                        "\n",
                                        lvlSpaces,
                                        returnPathToRoot(node), "[['",
                                        collapsingColName,
                                        "']] <- '",
                                        GetAttribute(node, collapsingColName), "';");
      }
      if (isLeaf(node)) {
        ### Start the statement to set the value
        node$extractionscript <- paste0(node$extractionscript, "\n",
                                        lvlSpaces,
                                        returnPathToRoot(node), "[['", valueName, "']] <-");
      }
    }

    if (isNotLeaf(node)) {
      ### So this node has children ('leaves'), which means that the node itself
      ### does not represent any coded element; it's just used for organisation.
      node$extractionscript <- paste0(node$extractionscript, "\n",
                                      lvlSpaces, repStr("#", 80-lvlnchar), "\n",
                                      lvlSpaces, "###\n",
                                      paste0(strwrap(toupper(node[[activityColName]]),
                                                     width=76-lvlnchar, prefix=paste0(lvlSpaces, "### ")),
                                              collapse="\n"),
                                      "\n", lvlSpaces, "###",
                                      "\n", lvlSpaces,repStr("#", 80-lvlnchar), "\n\n");
    } else {
      ### Run the script to create the code for the scoring of this extraction script bit
      node$extractionscript <-
        paste0(node$extractionscript, "\n",
               leafExtractionscript(node,
                                    lvlSpaces=lvlSpaces,
                                    recursionNesting=recursionNesting));
    }
      
  }
});

extractionScriptBody <- paste0(repStr("#", 80), "\n",
                               repStr("#", 80), "\n",
                               "######", repStr(68), "######\n",
                               "######       ",
                               "M E T A B E F O R    E X T R A C T I O N   S C R I P T",
                               "       ######\n",
                               "######", repStr(68), "######\n",
                               repStr("#", 80), "\n",
                               repStr("#", 80), "\n\n");

### Extract all extraction script bits
extractionScriptBody <- paste0(extractionScriptBody,
                               paste0(unlist(FindNode(extractionScriptTree, 
                                                      name=rootName)$Get("extractionscript")),
                                      collapse="\n"));

### Add extractionscript bits to the tree, now for the
### recursive elements

extractionScriptBody <- paste0(extractionScriptBody,
                               "\n", repStr("#", 80), "\n",
                               repStr("#", 80), "\n",
                               "######", repStr(68), "######\n",
                               "######                ",
                               "R E C U R S I V E   E L E M E N T S",
                               "                 ######\n",
                               "######", repStr(68), "######\n",
                               repStr("#", 80), "\n",
                               repStr("#", 80), "\n");

extractionScriptBody <- paste0(extractionScriptBody,
                               paste0(unlist(FindNode(extractionScriptTree,
                                                      name=recursionsName)$Get("extractionscript")),
                                      collapse="\n"));

extractionScript <- extractionScriptBody;

writeLines(paste0(extractionScript, collapse=""),
           file.path(basePath,
                     "extraction script template foundation.R"));

```

```{r build-checklist}

###############################################################################
###############################################################################
### Generate checklist                                                      ###
###############################################################################
###############################################################################

renderChecklist(extractionScriptTree,
                checklistRoot = 'intervention',
                outputFile = file.path(basePath, "checklist.html"),
                css = file.path(basePath, 'checklist.css'),
                definitions = definitions);

###############################################################################

```
