---
title: "Data Extraction Structure"
author: "Gjalt-Jorn Ygram Peters"
date: "`r format(Sys.time(), '%Y-%m-%d om %X');`"
output: html_document
---

```{r message=FALSE, warning=FALSE, echo=FALSE}

########################################################################
### Paths
########################################################################

### Add any relevant paths to this vector. The script will select the
### correct path itself.

basePathVector <- c("B:/Data/research/intervention-planning-sysrev",
                    "/home/usf/public_html/wim/intervention-planning-sysrev");

########################################################################
### Set the variables with the paths
########################################################################

### Check which paths exist and set the first existing path in the list
### as the base path
basePath <- basePathVector[sapply(basePathVector, dir.exists)][1];
if (is.na(basePath)) stop("None of the basePaths exists!");

### Set the additional paths
outputPath <- basePath;

########################################################################
### Load packages
########################################################################

### Packages
require('userfriendlyscience');
safeRequire('googlesheets');
safeRequire('data.tree');
safeRequire('networkD3')
safeRequire('DiagrammeR')
safeRequire('DiagrammeRsvg')
safeRequire('xtable')

########################################################################
### Load spreadsheet
########################################################################

### Get authorization to read Google sheet
#gs_auth(new_user=TRUE);

### Read google sheet

tryCatch({
    dat <- gs_read(gs_url(paste0("https://docs.google.com/spreadsheets/d/",
                                 "1g__lA6Qd8x9UcUMIZGq_xMcZt584sJ-1sMaLmxm3nUU")));
    cat0("\nStoring in local file.\n");
    write.csv(dat,
              file.path(basePath, 'wim-googlesheet.csv'));
  },
  error = function(e) {
    cat0("\nReading from local file.\n");
    dat <- read.csv(file.path(basePath, 'wim-googlesheet.csv'));
  });

########################################################################
### Settings (will become parameters/arguments)
########################################################################

rootName <- 'intervention';
recursionsName <- 'recursion';
lvlIndentString <- "  ";
repeatingColName <- "Repeating";
recursionColName <- "Recursion";
collapsingColName <- "Collapse";
ownerColName <- "Owner";
parentColName <- "Parent";
identifierColName <- "Identifier";
activityColName <- "Activity";
descriptionColName <- "Description";
valueName <- "value";
defaultValue <- "NA";

########################################################################
### Process data
########################################################################

dataFrameNetwork <- as.data.frame(dat[!is.na(dat$Identifier),
                                      unique(c('Identifier', 'Parent', names(dat)))]);
dataFrameNetwork$Parent[is.na(dataFrameNetwork$Parent)] <- 'res';

### Check for non-existent parents
nonExistentParents <- !(dataFrameNetwork$Parent %in% c('res', dataFrameNetwork$Identifier));
if (any(nonExistentParents)) {
  message("Note: the items with the following identifiers have a parent that ",
          "cannot be found in the list of parents: ",
          paste0(paste0("'",
                        dataFrameNetwork$Identifier[nonExistentParents],
                        "' with parent '",
                        dataFrameNetwork$Parent[nonExistentParents],
                        "' on line ", 1+which(dat$Identifier %in% dataFrameNetwork$Identifier[nonExistentParents])),
                 collapse=", "),
          "), so I'm ignoring these.");
}

extractionScriptTree <- FromDataFrameNetwork(dataFrameNetwork);

### Check for unique names
if (!AreNamesUnique(extractionScriptTree)) {
  stop("Not all identifiers are unique!");
}

### https://github.com/gluc/data.tree/issues/88
#SetGraphStyle(extractionScriptTree, rankdir = "LR");
#plot(extractionScriptTree);

### Set generic styles
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "black",
                                                    color='black', shape="box",
                                                    style="rounded"));

wrap <- function(string, width=40) {
  return(paste0(strwrap(string, width=width), collapse="\n"));
}

##################################################################################
### Set specific styles

### Set parent-only nodes to grey
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "grey",
                                                    label = node$Activity,
                                                    color='grey'),
                        filterFun = function(node) return(ifelse(is.null(node$Description), TRUE, FALSE)));

### Set regular nodes
extractionScriptTree$Do(function(node) SetNodeStyle(node, color='black', fontcolor='black',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                           width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Description), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "green", color='green',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Repeating), FALSE, node$Repeating)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded, dotted",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE,
                                                                 ifelse((node$Recursion!='TRUE'), TRUE, FALSE))));

extractionScriptDiagram <- ToDiagrammeRGraph(extractionScriptTree, direction = "descend");

extractionScriptDiagram <- set_global_graph_attrs(extractionScriptDiagram, "layout", "dot", "graph");
extractionScriptDiagram <- add_global_graph_attrs(extractionScriptDiagram, "rankdir", "LR", "graph");

### Temporary to speed up the rest

# render_graph(extractionScriptDiagram);

export_graph(extractionScriptDiagram,
             file_name=file.path(basePath,
                     "extraction script tree.svg"));

returnPathToRoot <- function(node, considerRoot = rootName) {
  res <- paste0(rev(unlist(sapply(Traverse(node, traversal='ancestor'),
                                  function(x) return(x$name)),
                           recursive=TRUE)), collapse="$");
  res <- gsub(paste0("^.*\\$", considerRoot, "$"), "", res);
  res <- gsub(paste0("^.*\\$", considerRoot, "\\$"), "\\$", res);
  return(res);
}

isCollapsing <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (trim(toupper(x)) == "OR") {
    return(TRUE);
  } else if (trim(toupper(x)) == "AND") {
    return(TRUE);
  } else {
    stop("For 'Recursion', value '", x, "' encountered.");
  }
}

isRecursive <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (nchar(trim(x)) > 0) {
    return(TRUE);
  }
}

isRepeating <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (trim(toupper(x)) == "FALSE") {
    return(FALSE);
  } else if (trim(toupper(x)) == "TRUE") {
    return(TRUE);
  } else {
    stop("For 'Repeating', value '", x, "' encountered.");
  }
}

hasOwner <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (nchar(trim(x)) > 0) {
    return(TRUE);
  }
}

leafExtractionscript <- function(node, lvlSpaces="  ",
                                 recursionNesting=0) {
  #### Initialize values
  addScoring <- FALSE;
  extraInfo <- "";
  lvlnchar <- nchar(lvlSpaces);
  ### Start scriptbit
  rslt <- paste0(lvlSpaces, repStr("#", 80-lvlnchar), "\n",
                 lvlSpaces, "###\n",
                 paste0(strwrap(toupper(node[[activityColName]]),
                                width=76-lvlnchar, prefix=paste0(lvlSpaces, "### ")),
                        collapse="\n"));
  
  if (!isRepeating(node[[repeatingColName]]) && !isRecursive(node[[recursionColName]])) {
    ### So this node is the simplest type; it doesn't repeat (only has one value), and
    ### it is not an instance of a recursive fragment.
    rslt <- paste0(rslt, "\n",
                   lvlSpaces, "###\n",
                   paste0(strwrap(node[[descriptionColName]],
                                  width=76-lvlnchar, prefix=paste0(lvlSpaces, "### ")),
                          collapse="\n"), "\n",
                   "\n",
                   lvlSpaces, "    ", defaultValue, "\n",
                   "\n");
    addScoring <- TRUE;
  } else if (isRepeating(node[[repeatingColName]]) && !isRecursive(node[[recursionColName]])) {
    ### This node is repeating but not recursive, so a simple list with named elements will do.
    rslt <- paste0(rslt, "\n",
                   lvlSpaces, "###\n",
                   paste0(strwrap(node[[descriptionColName]],
                                  width=76-lvlnchar, prefix=paste0(lvlSpaces, "### ")),
                          collapse="\n"), "\n",
                   lvlSpaces, "###\n",
                   "\n",
                   lvlSpaces, "    list('",
                   ifelse(is.null(node[[ownerColName]]),
                          node$name,
                          node[[ownerColName]]),
                   "1' = NA,\n",
                   lvlSpaces, "         '",
                   ifelse(is.null(node[[ownerColName]]),
                          node$name,
                          node[[ownerColName]]),
                   "2' = NA)\n",
                   "\n");
    addScoring <- TRUE;
    if (hasOwner(node[[ownerColName]])) {
      extraInfo <- paste0("\n",
                          lvlSpaces, "###\n",
                          lvlSpaces, "### Must have one list element for each '",
                          node[[ownerColName]],
                          "' element, and\n",
                          lvlSpaces, "### the name of each list element must be ",
                          "the same.");
    }
  } else if (isRecursive(node[[recursionColName]])) {
    ### This node is recursive, and so probably repeating.
    
    ### Determine the path to the root of this element
    currentElementName <- ifelse(isRepeating(node[[repeatingColName]]),
                                 paste0(node$name, "_.1._"),
                                 node$name)
    currentElementRoot <- paste0("res", returnPathToRoot(node$parent),
                                 "$", currentElementName);
    
    rslt <- paste0(rslt, "\n",
                   lvlSpaces, "###\n",
                   paste0(strwrap(node[[descriptionColName]],
                                  width=76-lvlnchar, prefix=paste0(lvlSpaces, "### ")),
                          collapse="\n"), "\n",
                   lvlSpaces, "###\n",
                   lvlSpaces, "### [ Recursive element '", node[[recursionColName]], "']\n",
                   lvlSpaces, "###\n");
    
    if (isRepeating(node[[repeatingColName]])) {
      rslt <- paste0(rslt,
                     lvlSpaces, "### This recursive element can occur multiple times");
      if (hasOwner(node[[ownerColName]])) {
        rslt <- paste0(rslt, ",\n",
                       lvlSpaces, "### specifically, once for each '",
                       node[[ownerColName]], "'.\n");
      }
      rslt <- paste0(rslt,
                     lvlSpaces, "### You may want to copy the lines below, until the text\n",
                     lvlSpaces, "### <<<END RECURSIVE ELEMENT ", toupper(node$name), ">>>\n",
                     lvlSpaces, "### and paste them below this first occurrence in case it does\n",
                     lvlSpaces, "### occur more than once.\n\n");
    }

    rslt <- paste0(rslt,
                   lvlSpaces, "    res", returnPathToRoot(node$parent),
                   "$AddChild('", currentElementName, "');\n\n",
                   lvlSpaces, "###\n");
    
    if (isRepeating(node[[repeatingColName]])) {
      rslt <- paste0(rslt,
                     lvlSpaces, "### <<<END RECURSIVE ELEMENT ", toupper(node$name), ">>>");
    }
    
  }
  ### Add scoring, if necessary
  if (addScoring) {
    rslt <- paste0(rslt,
                   paste0(sapply(strsplit(node$Get('Scoring'), "|", fixed=TRUE),
                                 function(x) {
                                   return(strwrap(trim(x), width=76-lvlnchar,
                                                  prefix=paste0(lvlSpaces, "### ")));
                                   }), collapse="\n"));
  }
  rslt <- paste0(rslt, extraInfo);
  
  ### Close this element
  rslt <- paste0(rslt,
                 "\n", lvlSpaces, "###",
                 "\n", lvlSpaces,
                 repStr("#", 80-lvlnchar), "\n");
  return(rslt);
}

### Add extractionscript bits to the tree, first for the
### regular extractionscript

rootLevel <- FindNode(extractionScriptTree, name=rootName)$level;

FindNode(extractionScriptTree, name=rootName)$Do(function(node) {

  ### We're just starting, so we're not in any nested recursions yet
  recursionNesting <- 0;
  
  if (node$name == rootName) {
    node$extractionscript <- paste0("### Create data.tree object\n",
                                    "res <- Node$new('", rootName, "');\n");
  } else {
    
    lvlSpaces <- repStr(lvlIndentString, node$level - rootLevel - 1);
    lvlnchar <- nchar(lvlSpaces);

    if (!isRecursive(node[[recursionColName]])) {
      
      ### If this node is recursive, we shouldn't create the child yet,
      ### And we shouldn't start setting the value yet.
      
      node$extractionscript <- paste0(lvlSpaces,
                                      "res",
                                      returnPathToRoot(node$parent),
                                      "$AddChild('", node$name, "');");
      if (isCollapsing(GetAttribute(node, collapsingColName))) {
        node$extractionscript <- paste0(node$extractionscript,
                                        "\n",
                                        lvlSpaces,
                                        "res",
                                        returnPathToRoot(node), "[['",
                                        collapsingColName,
                                        "']] <- '",
                                        GetAttribute(node, collapsingColName), "';");
      }
      if (isLeaf(node)) {
        ### Start the statement to set the value
        node$extractionscript <- paste0(node$extractionscript, "\n",
                                        lvlSpaces,
                                        "res",
                                        returnPathToRoot(node), "[['", valueName, "']] <-");
      }
    }
    
    if (isNotLeaf(node)) {
      ### So this node has children ('leaves'), which means that the node itself
      ### does not represent any coded element; it's just used for organisation.
      node$extractionscript <- paste0(node$extractionscript, "\n",
                                      lvlSpaces, repStr("#", 80-lvlnchar), "\n",
                                      lvlSpaces, "###\n",
                                      paste0(strwrap(toupper(node[[activityColName]]),
                                                     width=76-lvlnchar, prefix=paste0(lvlSpaces, "### ")),
                                              collapse="\n"),
                                      "\n", lvlSpaces, "###",
                                      "\n", lvlSpaces,repStr("#", 80-lvlnchar), "\n");
    } else {
      ### Run the script to create the code for the scoring of this extraction script bit
      node$extractionscript <-
        paste0(node$extractionscript, "\n",
               leafExtractionscript(node,
                                    lvlSpaces=lvlSpaces,
                                    recursionNesting=recursionNesting));
    }
      
  }
});

extractionScriptBody <- paste0(repStr("#", 80), "\n",
                               repStr("#", 80), "\n",
                               "######", repStr(68), "######\n",
                               "######       ",
                               "M E T A B E F O R    E X T R A C T I O N   S C R I P T",
                               "       ######\n",
                               "######", repStr(68), "######\n",
                               repStr("#", 80), "\n",
                               repStr("#", 80), "\n\n");

### Extract all extraction script bits
extractionScriptBody <- paste0(extractionScriptBody,
                               paste0(unlist(FindNode(extractionScriptTree, 
                                                      name=rootName)$Get("extractionscript")),
                                      collapse="\n"));

### Add extractionscript bits to the tree, now for the
### recursive elements

extractionScriptBody <- paste0(extractionScriptBody,
                               "\n", repStr("#", 80), "\n",
                               repStr("#", 80), "\n",
                               "######", repStr(68), "######\n",
                               "######                ",
                               "R E C U R S I V E   E L E M E N T S",
                               "                 ######\n",
                               "######", repStr(68), "######\n",
                               repStr("#", 80), "\n",
                               repStr("#", 80), "\n");

recursionRootLevel <- FindNode(extractionScriptTree, name=recursionsName)$level;

FindNode(extractionScriptTree, name=recursionsName)$Do(function(node) {
  if (node$name == recursionsName) {
    node$extractionscript <- "";
  } else  {
    if (node$level == recursionRootLevel + 1) {
      node$extractionscript <- paste0(node$extractionscript,
                                      "\n",
                                      "#", repStr(">", 78), "#\n",
                                      "#", repStr(">", 78), "#\n",
                                      "#>> ", node$name,
                                      repStr(73-nchar(node$name)), ">>#\n",
                                      "#", repStr(">", 78), "#\n",
                                      "#", repStr(">", 78), "#\n\n");
    }
    node$extractionscript <- paste0(node$extractionscript,
                                    "recEl",
                                    returnPathToRoot(node$parent,
                                                     considerRoot=recursionsName),
                                    "$AddChild('", node$name, "');");
  }
});

extractionScriptBody <- paste0(extractionScriptBody,
                               paste0(unlist(FindNode(extractionScriptTree,
                                                      name=recursionsName)$Get("extractionscript")),
                                      collapse="\n"));

extractionScript <- #paste0(extractionScriptStructurePreparation,
                           extractionScriptBody;

writeLines(paste0(extractionScript, collapse=""),
           file.path(basePath,
                     "extraction script template foundation.R"));

###############################################################################

### http://stackoverflow.com/questions/3665115/create-a-file-in-memory-for-user-to-download-not-through-server

checklistBody <-
  paste0("<html><body>",
         sapply(Traverse(extractionScriptTree,
                         traversal="pre-order"),
                function(x) {
                  if (isNotLeaf(x)) {
                    lvl <- 2; #x$level;
                    res <- paste0("<h", lvl, ">", x$ChecklistTitle, "</h", lvl, ">\n");
                  } else {
                    lvl <- 3; #x$level;
                    id <- x$name;
                    res <- paste0("<h", lvl, ">",
                                  "<input type='checkbox' name='", id, "' />",
                                  "<label for='", id, "'>",
                                  x$ChecklistTitle, "</label></h", lvl, ">\n",
                                  "<p>", x$ChecklistDescription, "</p>",
                                  "<p><em>In the IM book at page", x$BookReference, " and further.</em></p>");
                  }
                  return(res);
                }), "\n</body></html>\n", collapse="\n");

writeLines(paste0(checklistBody, collapse=""),
           file.path(basePath,
                     "checklist.html"));

###############################################################################


# export_graph(grViz(ToGraphViz(extractionScriptTree)),
#              file_name=file.path(basePath,
#                      "extraction script tree.png"));

# returnPathToRoot <- function(node) {
#   if (node$isRoot) return(node$name) else return(list(node$name, returnPathToRoot(node$parent)));
# }

```
