---
title: "Data Extraction Structure"
author: "Gjalt-Jorn Ygram Peters"
date: "`r format(Sys.time(), '%Y-%m-%d om %X');`"
output: html_document
---

```{r message=FALSE, warning=FALSE, echo=FALSE}

########################################################################
### Paths
########################################################################

### Add any relevant paths to this vector. The script will select the
### correct path itself.

basePathVector <- c("B:/Data/research/intervention-planning-sysrev",
                    "/home/usf/public_html/wim/intervention-planning-sysrev");

########################################################################
### Set the variables with the paths
########################################################################

### Check which paths exist and set the first existing path in the list
### as the base path
basePath <- basePathVector[sapply(basePathVector, dir.exists)][1];
if (is.na(basePath)) stop("None of the basePaths exists!");

### Set the additional paths
outputPath <- basePath;

########################################################################
### Load packages
########################################################################

### Packages
require('userfriendlyscience');
safeRequire('googlesheets');
safeRequire('data.tree');
safeRequire('networkD3')
safeRequire('DiagrammeR')
safeRequire('DiagrammeRsvg')
safeRequire('xtable')

########################################################################
### Load spreadsheet
########################################################################

### Get authorization to read Google sheet
#gs_auth(new_user=TRUE);

### Read google sheet

tryCatch({
    dat <- gs_read(gs_url(paste0("https://docs.google.com/spreadsheets/d/",
                                 "1g__lA6Qd8x9UcUMIZGq_xMcZt584sJ-1sMaLmxm3nUU")));
    cat0("\nStoring in local file.\n");
    write.csv(dat,
              file.path(basePath, 'wim-googlesheet.csv'));
  },
  error = function(e) {
    cat0("\nReading from local file.\n");
    dat <- read.csv(file.path(basePath, 'wim-googlesheet.csv'));
  });

########################################################################
### Process data
########################################################################

dataFrameNetwork <- as.data.frame(dat[!is.na(dat$Identifier),
                                      unique(c('Identifier', 'Parent', names(dat)))]);
dataFrameNetwork$Parent[is.na(dataFrameNetwork$Parent)] <- 'res';

### Check for non-existent parents
nonExistentParents <- !(dataFrameNetwork$Parent %in% c('res', dataFrameNetwork$Identifier));
if (any(nonExistentParents)) {
  message("Note: the items with the following identifiers have a parent that ",
          "cannot be found in the list of parents: ",
          paste0(paste0("'",
                        dataFrameNetwork$Identifier[nonExistentParents],
                        "' with parent '",
                        dataFrameNetwork$Parent[nonExistentParents],
                        "' on line ", 1+which(dat$Identifier %in% dataFrameNetwork$Identifier[nonExistentParents])),
                 collapse=", "),
          "), so I'm ignoring these.");
}

extractionScriptTree <- FromDataFrameNetwork(dataFrameNetwork);

### https://github.com/gluc/data.tree/issues/88
#SetGraphStyle(extractionScriptTree, rankdir = "LR");
#plot(extractionScriptTree);

### Set generic styles
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "black",
                                                    color='black', shape="box",
                                                    style="rounded"));

wrap <- function(string, width=40) {
  return(paste0(strwrap(string, width=width), collapse="\n"));
}

##################################################################################
### Set specific styles

### Set parent-only nodes to grey
extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "grey",
                                                    label = node$Activity,
                                                    color='grey'),
                        filterFun = function(node) return(ifelse(is.null(node$Description), TRUE, FALSE)));

### Set regular nodes
extractionScriptTree$Do(function(node) SetNodeStyle(node, color='black', fontcolor='black',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                           width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Description), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "green", color='green',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Repeating), FALSE, node$Repeating)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE, TRUE)));

extractionScriptTree$Do(function(node) SetNodeStyle(node, fontcolor = "orange", color='orange',
                                                    shape="box", style="rounded, dotted",
                                                    label = paste0(wrap(node$Activity,
                                                                        width=60), "\n\n",
                                                                   wrap(node$Description,
                                                                        width=60))),
                        filterFun = function(node) return(ifelse(is.null(node$Recursion), FALSE,
                                                                 ifelse((node$Recursion!='TRUE'), TRUE, FALSE))));

extractionScriptDiagram <- ToDiagrammeRGraph(extractionScriptTree, direction = "descend");

extractionScriptDiagram <- set_global_graph_attrs(extractionScriptDiagram, "layout", "dot", "graph");
extractionScriptDiagram <- add_global_graph_attrs(extractionScriptDiagram, "rankdir", "LR", "graph");

### Temporary to speed up the rest

# render_graph(extractionScriptDiagram);
# 
# export_graph(extractionScriptDiagram,
#              file_name=file.path(basePath,
#                      "extraction script tree.svg"));

returnPathToRoot <- function(node) {
  return(paste0(rev(unlist(sapply(Traverse(node, traversal='ancestor'),
                                  function(x) return(x$name)),
                           recursive=TRUE)), collapse="$"));
}

extractionScriptStructurePreparation <-
  paste0(sapply(Traverse(extractionScriptTree,
                         traversal="level",
                         filterFun=isNotLeaf),
                function(node) return(returnPathToRoot(node))),
         " <- list();\n", collapse="");

isCollapsing <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (trim(toupper(x)) == "OR") {
    return(TRUE);
  } else if (trim(toupper(x)) == "AND") {
    return(TRUE);
  } else {
    stop("For 'Recursion', value '", x, "' encountered.");
  }
}

isRecursive <- function(x) {
  if (is.null(x)) {
    return(FALSE);
  } else if (is.na(x)) {
    return(FALSE);
  } else if (nchar(x) == 0) {
    return(FALSE);
  } else if (nchar(trim(x)) > 0) {
    return(TRUE);
  }
}

extractionScriptBody <-
  paste0(sapply(Traverse(extractionScriptTree,
                         traversal="pre-order",
                         filterFun=isNotRoot),
                function(x) {

                  if (any(Get(x$children, isLeaf)) && (length(Get(x$children, isLeaf)) > 0)) {

                    ### Conveniently prune all branches, but not the entire (sub)-tree
                    pruneChildBranches <- function(node, minlevel=x$level) {
                      return(ifelse((node$level == minlevel) || isLeaf(node),
                                    TRUE, FALSE));
                      };
                    
                    childLeaves <- Traverse(x,
                                            traversal='pre-order',
                                            pruneFun=pruneChildBranches,
                                            filterFun=isLeaf);

                    ### Preparing the fields for printing
                    parsedChildren <- Get(childLeaves, function(node) {
                      
                      if (is.na(node$Get('Scoring'))) {
                        node$Scoring <- "";
                      }
                      
                      if (!is.character(node$Get('Scoring'))) {
                        stop("'Scoring' has non-character value, specifically '",
                             node$Get('Scoring'),
                             "' (for '", node$name, "'),");
                      }
                      
                      if (!isTRUE(node$Repeating) && !isRecursive(node$Recursion)) {
                        ### This element does not repeat and is not a recursion element,
                        ### so we only need to show what is required to score it
                        return(paste0("          ", repStr("#", 70), "\n",
                                      paste0(strwrap(toupper(node$Get('Activity')),
                                                     width=70, prefix="          ### "),
                                             collapse="\n"),
                                      "\n          ###\n",
                                      paste0(strwrap(node$Get('Description'),
                                                     width=70, prefix="          ### "),
                                             collapse="\n"),
                                      "\n          ",
                                      "\n          ", node$Get('name'), " = NA",
                                      "\n          \n",
                                      paste0(sapply(strsplit(node$Get('Scoring'), "|", fixed=TRUE),
                                                    function(x) {
                                                      return(strwrap(trim(x), width=70,
                                                                     prefix="          ### "))
                                                      }),
                                             collapse="\n"),
                                      "\n          ", repStr("#", 70)));
                      } else if (isTRUE(node$Repeating == TRUE) && !isRecursive(node$Recursion)) {
                        ### So this is a repeating element, but not recursive.
                        return(paste0("          ", repStr("#", 70), "\n",
                                      "          ### This is a repeating element.",
                                      "\n          ", node$name, "",
                                      "\n          ", node$Owner, "",
                                      "\n          ", repStr("#", 70)));
                      } else if (!isTRUE(node$Repeating == TRUE) && isRecursive(node$Recursion)) {
                        ### So this is not a repeating element, but it is recursive.
                        return(paste0("          ", repStr("#", 70), "\n",
                                      "          ### This is a repeating element.",
                                      "\n          ", repStr("#", 70)));
                      } else if (isTRUE(node$Repeating == TRUE) && isRecursive(node$Recursion)) {
                        ### So this is a repeating element and a recursive one.
                        return(paste0("          ", repStr("#", 70), "\n",
                                      "          ### This is a repeating element.",
                                      "\n          ", repStr("#", 70)));
                      }
                    });

                    res <- paste0(repStr("#", 80),
                                  "\n", 
                                  paste0(strwrap(x$Activity, width=72,
                                                 prefix='### '),
                                         collapse="\n\n"),
                                  "\n", repStr("#", 80), "\n\n");
                    res <- paste0(res,
                                  returnPathToRoot(x),
                                  "\n  [[length(", returnPathToRoot(x), ")+1]] <-\n    list(\n");

                    res <- paste0(res,
                                  paste0(parsedChildren,
                                         collapse="\n        ,\n"),
                                  "\n        );");

                  } else if (all(Get(x$children, 'isLeaf'))) {
                    res <- paste0(repStr("#", 80),
                                  "\n### Activity (all children are properties)\n",
                                  paste0(strwrap(x$Activity, width=72,
                                                 prefix='###   '),
                                         collapse="\n"),
                                  "\n###\n### Description\n",
                                  paste0(strwrap(x$Description, width=72,
                                                 prefix='###   '),
                                         collapse="\n"), "\n",
                                  repStr("#", 80), "\n\n");
                    res <- paste0(res,
                                  returnPathToRoot(x),
                                  "\n  [[length(", returnPathToRoot(x), ")+1]] <-\n    list();\n",
                                  "Identifier: ", x$name, "\n",
                                  "Parent: ", x$parent$name, "\n",
                                  "Children: ", vecTxtQ(Get(x$children, 'name')), "\n",
                                  "Repeating: ", x$Repeating, "\n",
                                  "Recursion: ", x$Recursion, "\n",
                                  "Collapse: ", x$Collapse, "\n",
                                  "\n");
                    res <- "";
                  } else if (isNotLeaf(x)) {
                    res <- paste0(repStr("#", 80), "\n",
                                  repStr("#", 80), "\n",
                                  "### ", x$Activity, "\n",
                                  repStr("#", 80), "\n",
                                  repStr("#", 80), "\n");
                  } else {
                    res <- paste0(repStr("#", 80),
                                  "\n### Activity\n",
                                  paste0(strwrap(x$Activity, width=72,
                                                 prefix='###   '),
                                         collapse="\n"),
                                  "\n###\n### Description\n",
                                  paste0(strwrap(x$Description, width=72,
                                                 prefix='###   '),
                                         collapse="\n"), "\n",
                                  repStr("#", 80), "\n\n",
                                  "Identifier: ", x$name, "\n",
                                  "Parent: ", x$parent$name, "\n",
                                  "Repeating: ", x$Repeating, "\n",
                                  "Recursion: ", x$Recursion, "\n",
                                  "Collapse: ", x$Collapse, "\n",
                                  "\n");
                    res <- "";
                  }
                  return(res);
                }), "\n", collapse="\n");

extractionScript <- paste0(extractionScriptStructurePreparation,
                           extractionScriptBody);

writeLines(paste0(extractionScript, collapse=""),
           file.path(basePath,
                     "extraction script template foundation.R"));

###############################################################################

### http://stackoverflow.com/questions/3665115/create-a-file-in-memory-for-user-to-download-not-through-server

checklistBody <-
  paste0("<html><body>",
         sapply(Traverse(extractionScriptTree,
                         traversal="pre-order"),
                function(x) {
                  if (isNotLeaf(x)) {
                    lvl <- 2; #x$level;
                    res <- paste0("<h", lvl, ">", x$ChecklistTitle, "</h", lvl, ">\n");
                  } else {
                    lvl <- 3; #x$level;
                    id <- x$name;
                    res <- paste0("<h", lvl, ">",
                                  "<input type='checkbox' name='", id, "' />",
                                  "<label for='", id, "'>",
                                  x$ChecklistTitle, "</label></h", lvl, ">\n",
                                  "<p>", x$ChecklistDescription, "</p>",
                                  "<p><em>In the IM book at page", x$BookReference, " and further.</em></p>");
                  }
                  return(res);
                }), "\n</body></html>\n", collapse="\n");

writeLines(paste0(checklistBody, collapse=""),
           file.path(basePath,
                     "checklist.html"));

###############################################################################


# export_graph(grViz(ToGraphViz(extractionScriptTree)),
#              file_name=file.path(basePath,
#                      "extraction script tree.png"));

# returnPathToRoot <- function(node) {
#   if (node$isRoot) return(node$name) else return(list(node$name, returnPathToRoot(node$parent)));
# }

```
